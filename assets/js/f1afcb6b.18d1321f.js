"use strict";(self.webpackChunkveezoo_docs=self.webpackChunkveezoo_docs||[]).push([[3862],{28453(e,n,r){r.d(n,{R:()=>i,x:()=>a});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},34929(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"vkl/kb-layer/attribute/types/number","title":"number","description":"Definition","source":"@site/docs/vkl/kb-layer/attribute/types/number.md","sourceDirName":"vkl/kb-layer/attribute/types","slug":"/vkl/kb-layer/attribute/types/number","permalink":"/vkl/kb-layer/attribute/types/number","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"number","sidebar_position":2},"sidebar":"vkl","previous":{"title":"date","permalink":"/vkl/kb-layer/attribute/types/date"},"next":{"title":"boolean","permalink":"/vkl/kb-layer/attribute/types/boolean"}}');var s=r(74848),o=r(28453);const i={title:"number",sidebar_position:2},a=void 0,l={},d=[{value:"Definition",id:"definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Integer",id:"integer",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsx)(n.p,{children:"A numeric attribute is used whenever you have a column or SQL expression that returns a number, e.g. an integer or a decimal number."}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["File: ",(0,s.jsx)(n.em,{children:"hitchhiker/knowledge-base/classes/Order.vkl"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        number Order_Total {\n            name.en: "Order Total"\n            synonym.en: ["Price", "Revenue", "Amount"]\n\n            unit: onto.Currency.USD\n\n            sql: "${ORDERS.order_total}"\n        }    \n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice the ",(0,s.jsx)(n.a,{href:"..",children:"unit"})," parameter, which allows Veezoo to display the value in the appropriate format to the user."]}),"\n",(0,s.jsxs)(n.p,{children:["As with the other kinds of attributes, you can also apply any kind of compatible SQL transformation inside ",(0,s.jsx)(n.code,{children:"sql"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's say instead that your attribute ",(0,s.jsx)(n.code,{children:"kb.Order.Order_Total"})," contains values in different currencies (USD, CHF, EUR), specified in the column ",(0,s.jsx)(n.code,{children:"ORDERS.currency"})," (imported as class ",(0,s.jsx)(n.code,{children:"kb.Order.Currency"}),").\nNow, summing these values up wouldn't make any sense. So we define a new attribute ",(0,s.jsx)(n.code,{children:"Order_Total_EUR"}),", which converts the values according to a fixed exchange rate."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        number Order_Total_EUR {\n            name.en: "Order Total (EUR)"\n            synonym.en: ["Price", "Revenue", "Order Total"]\n\n            unit: onto.Currency.EUR\n\n            sql: """\n                CASE ${kb.Order.Currency}\n                   WHEN \'USD\' THEN ${kb.Order.Order_Total} * 0.83\n                   WHEN \'CHF\' THEN ${kb.Order.Order_Total} * 0.92\n                   ELSE ${kb.Order.Order_Total}\n                END   \n            """\n\n        }    \n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice here that we have referred inside the curly brackets ",(0,s.jsx)(n.code,{children:"${...}"})," to a ",(0,s.jsx)(n.code,{children:"kb"})," concept, instead of a ",(0,s.jsx)(n.code,{children:"db"})," concept. This allows us to use recursively the definitions in the ",(0,s.jsx)(n.code,{children:"sql"})," from these ",(0,s.jsx)(n.code,{children:"kb"})," concepts."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, we could now build on top of ",(0,s.jsx)(n.code,{children:"kb.Order.Order_Total_EUR"})," like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        boolean Awesome {\n            name.en: "Awesome"\n\n            sql: "${kb.Order.Order_Total_EUR} > 1000"\n\n        }    \n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is a ",(0,s.jsx)(n.a,{href:"/vkl/kb-layer/attribute/types/boolean",children:"boolean"}),', defining "awesome" orders as those with a total order value normalized in Euro above 1000. How awesome is that!']}),"\n",(0,s.jsx)(n.h3,{id:"integer",children:"Integer"}),"\n",(0,s.jsxs)(n.p,{children:["You can also be more precise on the type of number and define it as an ",(0,s.jsx)(n.code,{children:"integer"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        integer Quantity {\n            name.en: "Quantity"\n            synonym.en: ["Qty"]\n\n            sql: "${ORDERS.quantity}"\n        }    \n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:'This will help Veezoo format the results more appropriately and allows you to ask questions such as "how many orders were there for each quantity", which Veezoo does not answer if it is for a fractional number.'})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);