"use strict";(self.webpackChunkveezoo_docs=self.webpackChunkveezoo_docs||[]).push([[3172],{28453(e,n,s){s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const t={},o=i.createContext(t);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},32733(e,n,s){s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"vkl/kb-layer/general/join","title":"join","description":"Definition","source":"@site/docs/vkl/kb-layer/general/join.md","sourceDirName":"vkl/kb-layer/general","slug":"/vkl/kb-layer/general/join","permalink":"/vkl/kb-layer/general/join","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"\u2699\ufe0f join","sidebar_position":5},"sidebar":"vkl","previous":{"title":"\u2699\ufe0f description","permalink":"/vkl/kb-layer/general/description"},"next":{"title":"\u2699\ufe0f synced_description","permalink":"/vkl/kb-layer/general/synced_description"}}');var t=s(74848),o=s(28453);const a={sidebar_label:"\u2699\ufe0f join",sidebar_position:5},l=void 0,r={},d=[{value:"Definition",id:"definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Intermediate Table",id:"intermediate-table",level:3},{value:"Multi-Joins",id:"multi-joins",level:3},{value:"Advanced Joins",id:"advanced-joins",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsx)(n.p,{children:"In some situations, your data schema may contain intermediate tables (a.k.a. junction tables), which represent many-to-many relationships."}),"\n",(0,t.jsx)(n.p,{children:"However, these tables can be confusing for Business Users to understand, since they only serve a purely relational modelling purpose and not a business concept per se."}),"\n",(0,t.jsxs)(n.p,{children:["In these cases, you may want to define a ",(0,t.jsx)(n.code,{children:"join"})," to go over these tables and hide them from your business users."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's look into some example of schemas that we would like to simplify to our business users over Veezoo using the property ",(0,t.jsx)(n.code,{children:"join"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"join"})," can be used inside ",(0,t.jsx)(n.code,{children:"relationship"}),", ",(0,t.jsx)(n.code,{children:"number"})," / ",(0,t.jsx)(n.code,{children:"integer"}),", ",(0,t.jsx)(n.code,{children:"boolean"}),", ",(0,t.jsx)(n.code,{children:"string"})," and ",(0,t.jsx)(n.code,{children:"date"}),". It is always defined as an Array of SQL Expressions, even if there is only one join needed."]}),"\n",(0,t.jsx)(n.h3,{id:"intermediate-table",children:"Intermediate Table"}),"\n",(0,t.jsx)(n.p,{children:"A very common kind of modelling in relational databases is that of an intermediate table with two foreign keys (and optionally a primary key)."}),"\n",(0,t.jsxs)(n.p,{children:["Example: A table ",(0,t.jsx)(n.code,{children:"CUSTOMER_LANGUAGE(customer_id, language_id)"})," that specifies the languages that a customer speaks, by using two foreign keys."]}),"\n",(0,t.jsx)(n.p,{children:"In this case, this is how we would model it in Veezoo:"}),"\n",(0,t.jsxs)(n.p,{children:["File: ",(0,t.jsx)(n.em,{children:"hitchhiker/knowledge-base/classes/Customer.vkl"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.CUSTOMER,\n    db.postgres.movie_db.public.CUSTOMER_LANGUAGE\n]\n\nkb {\n\n    class Customer {\n    \tname.en: "Customer"\n        sql: "${CUSTOMER.id}"\n    \t\n        relationship speaks_Language {\n            display_name.en: "speaks"\n            \n            tag: KB_Many2Many\n\n            to: kb.Language\n\n            // CUSTOMER -> CUSTOMER_LANGUAGE\n            join: [\n              "${CUSTOMER.id} = ${CUSTOMER_LANGUAGE.customer_id}"\n            ]\n\n            // this is used to join with LANGUAGE.id (the sql for kb.Language)\n            sql: "${CUSTOMER_LANGUAGE.language_id}"\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["First of all, we needed to add to our ",(0,t.jsx)(n.code,{children:"import"})," another table reference, namely to ",(0,t.jsx)(n.code,{children:"CUSTOMER_LANGUAGE"}),", so we can use its shorthand form."]}),"\n",(0,t.jsxs)(n.p,{children:["Similarly to the case of Foreign Keys described in the ",(0,t.jsx)(n.a,{href:"/vkl/kb-layer/class",children:"sql Overview for Class Relations"}),", we also need to specify the ",(0,t.jsx)(n.code,{children:"sql"})," here."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, we see for the first time the usage of ",(0,t.jsx)(n.code,{children:"join"}),". A relationship always goes from the parent class (e.g. ",(0,t.jsx)(n.code,{children:"kb.Customer"}),") to another class (e.g. ",(0,t.jsx)(n.code,{children:"kb.Language"}),"). Since the join path goes over an intermediate table, we need to specify how we get to the final ",(0,t.jsx)(n.code,{children:"CUSTOMER_LANGUAGE"})," table, namely first over the ",(0,t.jsx)(n.code,{children:"customer_id"})," foreign key."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, notice that this relationship has an explicit ",(0,t.jsx)(n.code,{children:"tag"})," set, in contrast to most of our relationships. ",(0,t.jsx)(n.code,{children:"KB_Many2Many"})," specifies that this is a many-to-many relationship, i.e. that customers may speak multiple languages and that languages may be spoken by multiple customers. The default is ",(0,t.jsx)(n.code,{children:"KB_Many2One"})," and is used when nothing is set."]}),"\n",(0,t.jsx)(n.p,{children:"Now, there is nothing special about this two foreign keys case. Maybe your intermediate table contains actually a numeric column, a date, boolean, instead of a second foreign key."}),"\n",(0,t.jsxs)(n.p,{children:["Let's say we have a table like ",(0,t.jsx)(n.code,{children:"CUSTOMER_EXTRA(customer_id, age)"}),". Following the same idea, we can have a new attribute defined like this:"]}),"\n",(0,t.jsxs)(n.p,{children:["File: ",(0,t.jsx)(n.em,{children:"hitchhiker/knowledge-base/classes/Customer.vkl"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.CUSTOMER,\n    db.postgres.movie_db.public.CUSTOMER_EXTRA\n]\n\nkb {\n\n    class Customer {\n    \tname.en: "Customer"\n        sql: "${CUSTOMER.id}"\n\n        integer Age {\n            name.en: "Age"\n\n            // CUSTOMER -> CUSTOMER_EXTRA\n            join: [\n              "${CUSTOMER.id} = ${CUSTOMER_EXTRA.customer_id}"\n            ]\n\n            sql: "${CUSTOMER_EXTRA.age}"\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"multi-joins",children:"Multi-Joins"}),"\n",(0,t.jsx)(n.p,{children:"If the schema is more complicated, we may need to go over several intermediate tables to find the information we need."}),"\n",(0,t.jsxs)(n.p,{children:["Let's look at the following artificial example with tables ",(0,t.jsx)(n.code,{children:"CUSTOMER(id, name)"}),", ",(0,t.jsx)(n.code,{children:"CUSTOMER_INFO(customer_id, customer_extra_id)"}),", ",(0,t.jsx)(n.code,{children:"CUSTOMER_EXTRA(id, age)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In this case, we will need to define how the path of ",(0,t.jsx)(n.code,{children:"join"})," needs to be performed."]}),"\n",(0,t.jsxs)(n.p,{children:["File: ",(0,t.jsx)(n.em,{children:"hitchhiker/knowledge-base/classes/Customer.vkl"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.CUSTOMER,\n    db.postgres.movie_db.public.CUSTOMER_INFO,\n    db.postgres.movie_db.public.CUSTOMER_EXTRA\n]\n\nkb {\n\n    class Customer {\n    \tname.en: "Customer"\n        sql: "${CUSTOMER.id}"\n\n        integer Age {\n            name.en: "Age"\n\n            // CUSTOMER -> CUSTOMER_INFO -> CUSTOMER_EXTRA\n            join: [\n             "${CUSTOMER.id} = ${CUSTOMER_INFO.customer_id}", \n             "${CUSTOMER_INFO.customer_extra_id} = ${CUSTOMER_EXTRA.id}"\n            ]\n\n            sql: "${CUSTOMER_EXTRA.age}"\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you need even more joins, just define them inside the array. Also, don't forget to add the table to the ",(0,t.jsx)(n.code,{children:"import"})," statement at the top."]}),"\n",(0,t.jsx)(n.h3,{id:"advanced-joins",children:"Advanced Joins"}),"\n",(0,t.jsx)(n.p,{children:"Finally, your Join may not be of the form 'column A = column B'. Still, with VKL you can put whatever fancy SQL expression you want for the join."}),"\n",(0,t.jsx)(n.p,{children:"Let's take the following example."}),"\n",(0,t.jsxs)(n.p,{children:["We have the tables ",(0,t.jsx)(n.code,{children:"CUSTOMER(id, name, private_id, company_id, segment_valid)"})," and ",(0,t.jsx)(n.code,{children:"CUSTOMER_SEGMENT_INFO(id, website)"}),", where ",(0,t.jsx)(n.code,{children:"private_id"})," and ",(0,t.jsx)(n.code,{children:"company_id"})," are foreign keys to ",(0,t.jsx)(n.code,{children:"CUSTOMER_SEGMENT_INFO"}),", but only one is set at a time and the reference only makes sense if ",(0,t.jsx)(n.code,{children:"segment_valid"})," is set to 1, because... why not. And we want in the end to get the website."]}),"\n",(0,t.jsx)(n.p,{children:"This is how it will look like:"}),"\n",(0,t.jsxs)(n.p,{children:["File: ",(0,t.jsx)(n.em,{children:"hitchhiker/knowledge-base/classes/Customer.vkl"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import: [\n    db.postgres.movie_db.public.CUSTOMER,\n    db.postgres.movie_db.public.CUSTOMER_SEGMENT_INFO\n]\n\nkb {\n\n    class Customer {\n        name.en: "Customer"\n        sql: "${CUSTOMER.id}"\n\n        string Website {\n            name.en: "Website"\n\n            // CUSTOMER -> CUSTOMER_SEGMENT_INFO\n            join: [\n              "COALESCE(${CUSTOMER.private_id}, ${CUSTOMER.company_id}) = ${CUSTOMER_SEGMENT_INFO.id} AND ${CUSTOMER.segment_valid} = 1"\n            ]\n\n            sql: "${CUSTOMER_SEGMENT_INFO.website}"\n        }\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);