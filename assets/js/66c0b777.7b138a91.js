"use strict";(self.webpackChunkveezoo_docs=self.webpackChunkveezoo_docs||[]).push([[277],{28453(e,n,t){t.d(n,{R:()=>l,x:()=>r});var i=t(96540);const s={},a=i.createContext(s);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},54605(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"vkl/kb-layer/function/function","title":"function","description":"Definition","source":"@site/docs/vkl/kb-layer/function/function.md","sourceDirName":"vkl/kb-layer/function","slug":"/vkl/kb-layer/function/","permalink":"/vkl/kb-layer/function/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"function"},"sidebar":"vkl","previous":{"title":"VQL","permalink":"/vkl/kb-layer/vql/"},"next":{"title":"\u2699\ufe0f arguments","permalink":"/vkl/kb-layer/function/arguments"}}');var s=t(74848),a=t(28453);const l={title:"function"},r=void 0,o={},c=[{value:"Definition",id:"definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Examples",id:"examples",level:2},{value:"CB_Many2One: Correlation",id:"cb_many2one-correlation",level:3},{value:"CB_One2One: Length",id:"cb_one2one-length",level:3},{value:"CB_One2Maybe: Leap Year",id:"cb_one2maybe-leap-year",level:3},{value:"CB_One2Maybe with single_value_only: Regex match",id:"cb_one2maybe-with-single_value_only-regex-match",level:3}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"function"})," in Veezoo allows users to create custom SQL functions or transformations that may not be readily available in Veezoo off-the-shelf. It's a useful feature for adding specialized functionality that is available in your database, e.g. linear regression functions."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"function"})," is defined with several properties:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),": A name for the function, used when calling it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"synonym"}),": Alternative ways to refer to this function in a question."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dynamic_display_name"}),": The name of the function as it will be displayed in Veezoo, including placeholders for the arguments."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dynamic_autocomplete"}),": (Optional) The pattern that should be displayed in the autocomplete, when a user is typing a question."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tag"}),": The type of function. Can be one of the following:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CB_Many2One"})," for aggregation functions. These functions take multiple values and return a single value, like ",(0,s.jsx)(n.code,{children:"sum"})," or ",(0,s.jsx)(n.code,{children:"average"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CB_One2One"})," for transformation functions. These functions transform one value into another, like converting temperatures or changing data types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CB_One2Maybe"})," for filter functions. These functions return true or false."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"arguments"}),": The types of arguments the function accepts."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"return"}),": The return type of the function. Left out for ",(0,s.jsx)(n.code,{children:"CB_One2Maybe"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sql_select"}),": The SQL equivalent of the function for the SELECT clause. It uses placeholders (",(0,s.jsx)(n.code,{children:"$1"}),", ",(0,s.jsx)(n.code,{children:"$2"}),", etc.) for the arguments."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sql_where"}),": Especially for ",(0,s.jsx)(n.code,{children:"CB_One2Maybe"}),", the SQL equivalent of the function for the WHERE clause. It uses placeholders (",(0,s.jsx)(n.code,{children:"$1"}),", ",(0,s.jsx)(n.code,{children:"$2"}),", etc.) for the arguments."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"cb_many2one-correlation",children:"CB_Many2One: Correlation"}),"\n",(0,s.jsxs)(n.p,{children:["Let's consider a real-world example where we define a function to calculate the ",(0,s.jsx)(n.code,{children:"Correlation"})," between two number series:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function Correlation {\n   name: "Correlation"\n   \n   // That\'s what gets displayed to the end user\n   dynamic_display_name: "Correlation of $1 and $2"\n   \n   // It is an aggregation\n   tag: CB_Many2One\n\n   // It takes 2 series of numbers\n   arguments: [\n       number,\n       number\n   ]\n\n   // It returns another number\n   return: number\n\n   sql_select: "CORR($1, $2)"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"name"}),' of the function is "Correlation".']}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"dynamic_display_name"}),' is "Correlation of $1 and $2", where ',(0,s.jsx)(n.code,{children:"$1"})," and ",(0,s.jsx)(n.code,{children:"$2"})," are placeholders that will be replaced with the actual arguments when the function is called."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"tag"})," indicates this is an aggregation function (",(0,s.jsx)(n.code,{children:"CB_Many2One"}),"), meaning it takes multiple values (in this case, two series of numbers) and returns a single value (the correlation coefficient)."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"arguments"})," indicate that this function expects two arguments, both of which should be numbers."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"return"})," type is ",(0,s.jsx)(n.code,{children:"number"}),", meaning the function will return a numeric value."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"sql_select"})," contains the actual SQL code that will be executed when the function is called, with placeholders for the arguments. In this case, it's a call to the ",(0,s.jsx)(n.code,{children:"CORR"})," function in SQL, which calculates the correlation coefficient between two series of numbers."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["One caveat here is that the arguments will only be ",(0,s.jsx)(n.code,{children:"number"})," and therefore not ",(0,s.jsx)(n.code,{children:"integer"}),". To account for this, you have to adapt it like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\targuments: [\n       {  type: [ number, integer ]  },\n       {  type: [ number, integer ]  }\n   ]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This means that each argument accepts multiple types."}),"\n",(0,s.jsx)(n.h3,{id:"cb_one2one-length",children:"CB_One2One: Length"}),"\n",(0,s.jsx)(n.p,{children:"Let's say we want to implement a function that outputs the length of a string attribute."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function Length {\n    name: "Length"\n\n    synonym: "long"\n\n    // The name with the argument.\n    dynamic_display_name: "Length of $1"\n\n \t// In this case we map each string value to an integer\n \t// Therefore we use CB_One2One\n    tag: CB_One2One\n\n    arguments: [ string ]\n\n    return: integer\n\n    sql_select: "LENGTH($1)"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:['Now you can ask for instance "What is the average length of an email?", if you have an ',(0,s.jsx)(n.code,{children:"string Email"})," in your Knowledge Graph."]}),"\n",(0,s.jsx)(n.h3,{id:"cb_one2maybe-leap-year",children:"CB_One2Maybe: Leap Year"}),"\n",(0,s.jsxs)(n.p,{children:["In PostgreSQL, we can extract the year from a date using ",(0,s.jsx)(n.code,{children:"EXTRACT(YEAR FROM $1)"})," and then find out if a year is a Leap Year by\ndoing ",(0,s.jsx)(n.code,{children:"(EXTRACT(DOY FROM DATE (EXTRACT(YEAR FROM $1)::text || '-12-31')) = 366)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Using this, we can define a general ",(0,s.jsx)(n.code,{children:"function"})," in Veezoo that takes an arbitrary date attribute and filters for only dates in a leap year."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function Leap_Year {\n   name: "Leap Year"\n\n   // The name with the argument.\n   dynamic_display_name: "$1 is in leap year"\n\n   // To display this function in autocomplete\n   dynamic_autocomplete: "$1 in leap year"\n\n   tag: CB_One2Maybe\n\n    arguments: [\n       date\n    ]\n\n    sql_where: "(EXTRACT(DOY FROM DATE (EXTRACT(YEAR FROM $1)::text || \'-12-31\')) = 366)"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note here that we used ",(0,s.jsx)(n.code,{children:"sql_where"})," instead of ",(0,s.jsx)(n.code,{children:"sql_select"}),", because it's a ",(0,s.jsx)(n.code,{children:"CB_One2Maybe"}),". Another difference is that we don't have a ",(0,s.jsx)(n.code,{children:"return"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we need to explicitly add ",(0,s.jsx)(n.code,{children:"dynamic_autocomplete"}),", so it appears in the AutoComplete when typing a question. For instance, when you type something like 'How many customers with birthdate in', you will see 'birthdate in leap year' as a suggestion."]}),"\n",(0,s.jsx)(n.h3,{id:"cb_one2maybe-with-single_value_only-regex-match",children:"CB_One2Maybe with single_value_only: Regex match"}),"\n",(0,s.jsxs)(n.p,{children:["There are cases where you want to specify that one of the arguments is not a column, but rather a literal value. For that, we will use ",(0,s.jsx)(n.code,{children:"single_value_only: true"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"As an example, let's look into the POSIX Regular Expressions operator '~' in PostgreSQL."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function matches_regex {\n   name: "matches regex"\n   synonym: [\n      "matches",\n      "regex"\n   ] \n   \n   dynamic_display_name: "$1 matches regex $2"\n   dynamic_autocomplete: "$1 matches regex $2"\n   \n   tag: CB_One2Maybe\n   \n   arguments: [ \n      { type: [string, class] },\n      { type: string, single_value_only: true}\n   ]\n   \n   sql_where: "$1 ~ $2"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This allows you to ask questions like: \"Show me all customer with an email that matches '.*?@gmail.com'\""}),"\n",(0,s.jsxs)(n.p,{children:["Another thing to notice here is that the first argument can take either a ",(0,s.jsx)(n.code,{children:"string"})," or a ",(0,s.jsx)(n.code,{children:"class"}),". In the case of the ",(0,s.jsx)(n.code,{children:"class"}),", the resulting SQL uses only the ",(0,s.jsx)(n.code,{children:"sql"})," in the class definition, not ",(0,s.jsx)(n.code,{children:"name_sql"}),", nor any renamings on entities that you may have done in the Knowledge Graph."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);